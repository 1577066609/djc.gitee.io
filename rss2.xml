<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>小丁的小屋</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>最美的相遇，不言过往；最好的离别，不问归期。</description>
    <pubDate>Sat, 01 Aug 2020 07:51:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Mybatis简介</title>
      <link>http://yoursite.com/2020/08/01/mybatis%E7%AE%80%E4%BB%8B/</link>
      <guid>http://yoursite.com/2020/08/01/mybatis%E7%AE%80%E4%BB%8B/</guid>
      <pubDate>Sat, 01 Aug 2020 07:47:56 GMT</pubDate>
      <description>
      
        
        
          &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;1、简介&quot;&gt;&lt;a href=&quot;#1、简介&quot; class=&quot;headerlink&quot; title=&quot;1、简介&quot;&gt;&lt;/a&gt;1、简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是Mybatis&quot;&gt;&lt;a href=&quot;#1-1-什么是Mybat
        
      
      </description>
      
      
      <content:encoded><![CDATA[<a id="more"></a><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="1-1-什么是Mybatis"><a href="#1-1-什么是Mybatis" class="headerlink" title="1.1 什么是Mybatis"></a>1.1 什么是Mybatis</h3><h3 id="1-2-持久化"><a href="#1-2-持久化" class="headerlink" title="1.2 持久化"></a>1.2 持久化</h3><p>数据持久华</p><ul><li>持久化就是讲程序的数据在持久层和瞬时状态转化的过程</li><li>内存：<strong>断电既失</strong></li><li>数据库(jdbc),io文件持久化</li></ul><p><strong>为什么要持久化</strong></p><ul><li>有一些对象，不能让它丢掉</li><li>内存太贵了</li></ul><h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p>Dao层、Service层、Controller层…</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显</li></ul><h3 id="1-4-为什么需要Mybatis"><a href="#1-4-为什么需要Mybatis" class="headerlink" title="1.4 为什么需要Mybatis"></a>1.4 为什么需要Mybatis</h3><ul><li>帮助程序员讲数据存入到数据库中</li><li>方便</li><li>传统的JDBC代码很复杂。简化-》框架。自动化</li><li>不用Mybatis也可以，但是使用后，更容易上手。<strong>（技术没有高低之分）</strong></li><li>优点<ul><li>简单易学</li><li>灵活</li><li>sql和代码的分离，提高了可维护性。</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><p><strong>最重要的一点：使用的人多！</strong></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/08/01/mybatis%E7%AE%80%E4%BB%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>demo</title>
      <link>http://yoursite.com/2020/08/01/demo/</link>
      <guid>http://yoursite.com/2020/08/01/demo/</guid>
      <pubDate>Fri, 31 Jul 2020 17:01:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h1&gt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/08/01/demo/#disqus_thread</comments>
    </item>
    
    <item>
      <title>IOC理论推导</title>
      <link>http://yoursite.com/2020/07/31/2.IOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</link>
      <guid>http://yoursite.com/2020/07/31/2.IOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</guid>
      <pubDate>Fri, 31 Jul 2020 10:13:14 GMT</pubDate>
      <description>
      
        
        
          &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;2、IOC理论推导&quot;&gt;&lt;a href=&quot;#2、IOC理论推导&quot; class=&quot;headerlink&quot; title=&quot;2、IOC理论推导&quot;&gt;&lt;/a&gt;2、IOC理论推导&lt;/h2&gt;&lt;h3 id=&quot;2-1-原来实现&quot;&gt;&lt;a href=
        
      
      </description>
      
      
      <content:encoded><![CDATA[<a id="more"></a><h2 id="2、IOC理论推导"><a href="#2、IOC理论推导" class="headerlink" title="2、IOC理论推导"></a>2、IOC理论推导</h2><h3 id="2-1-原来实现"><a href="#2-1-原来实现" class="headerlink" title="2.1  原来实现"></a>2.1  原来实现</h3><ol><li>UserDao接口</li><li>UserDaoImpl实现类</li><li>UserService业务接口</li><li>UserServiceImpl业务实现类</li></ol><p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果程序的代码量十分大，修改一次的代价十分昂贵！</p><p>我们使用一个set接口实现，以及发生了革命性的变化</p><p><img src="https://i.loli.net/2020/07/29/Q2UygLKMIdWhtpX.png" alt="image-20200729222813217"></p><ul><li><strong>之前，程序是主动创建对象，控制权在程序猿手上</strong></li><li><strong>使用了set注入后，程序不再拥有主动性，而是变成了被动的接收对象</strong></li></ul><p>这种思想从本质上解决了问题，我们程序猿不用再去管理对象的创建了。</p><p>系统的耦合度大大降低了，可以更加专注的在业务的实现上。<strong>这是IOC的原型</strong></p><p><img src="https://i.loli.net/2020/07/29/d4KUb7tLpmD8RQX.png" alt="image-20200729223906856"></p><p>2.2 IOC本质</p><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，</strong>也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/07/31/2.IOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
